// ---------------------------------------------
// Prisma Schema â€” WaterTrade
// ---------------------------------------------

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --------------- Models ----------------

model User {
  id        String  @id @default(cuid())
  email     String  @unique
  name      String?
  role      Role    @default(USER)

  // External auth id (Clerk, etc.)
  clerkId   String? @unique

  // Relations
  listings            Listing[]                  // listings this user is selling
  buyerTransactions   Transaction[] @relation("BuyerTransactions")
  sellerTransactions  Transaction[] @relation("SellerTransactions")
  bids                Bid[]                      // back-relation for Bid.bidder
  notifications       Notification[]             // in-app notifications (optional)
  profile             UserProfile?              // one-to-one profile created via onboarding
  farms               Farm[]                    // NEW: farms owned by the user

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([role])
}

model Listing {
  id           String         @id @default(cuid())

  // Handy for UI & search
  title        String         @default("Untitled Listing")    // default added
  description  String?

  // Core water trade fields
  district     String
  waterType    String

  // Human-readable window (kept for display/back-compat)
  availability String

  // Real dates for sorting/filters
  availabilityStart DateTime  @default(now())                 // default added
  availabilityEnd   DateTime  @default(now())                 // default added

  acreFeet     Int
  pricePerAF   Int                 // cents

  // SELL or BUY (maps to form "type")
  kind         ListingKind     @default(SELL)

  status       ListingStatus   @default(ACTIVE)

  // Seller (optional for seed)
  seller       User?           @relation(fields: [sellerId], references: [id], onDelete: SetNull)
  sellerId     String?

  // Auction options
  isAuction      Boolean       @default(false)
  auctionEndsAt  DateTime?
  reservePrice   Int?              // cents per AF

  bids          Bid[]
  transactions  Transaction[]      // back-relation for Transaction.listing

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([status, isAuction, auctionEndsAt])
  @@index([district, waterType])
  @@index([createdAt])
}

model Bid {
  id         String   @id @default(cuid())

  listing    Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  listingId  String

  bidder     User     @relation(fields: [bidderId], references: [id], onDelete: Cascade)
  bidderId   String

  pricePerAF Int      // cents per AF
  createdAt  DateTime @default(now())

  @@index([listingId, createdAt])
  @@index([bidderId, createdAt])
}

model Transaction {
  id          String            @id @default(cuid())
  type        TransactionType
  status      TransactionStatus @default(INITIATED)

  listing     Listing   @relation(fields: [listingId], references: [id], onDelete: Restrict)
  listingId   String

  seller      User      @relation("SellerTransactions", fields: [sellerId], references: [id], onDelete: Restrict)
  sellerId    String

  buyer       User      @relation("BuyerTransactions", fields: [buyerId], references: [id], onDelete: Restrict)
  buyerId     String

  acreFeet    Int
  pricePerAF  Int        // cents
  totalAmount Int        // cents (acreFeet * pricePerAF)

  // --- NEW: snapshots so emails/audits are stable over time ---
  listingTitleSnapshot String?   // copy of Listing.title at creation
  sellerNameSnapshot   String?
  sellerEmailSnapshot  String?
  buyerNameSnapshot    String?
  buyerEmailSnapshot   String?

  // --- NEW: offer-specific niceties (optional) ---
  offerExpiresAt       DateTime?

  paymentMethod PaymentMethod?
  paymentId      String?     // Stripe PI id or Escrow.com id

  complianceApprovedBy String?
  complianceApprovedAt DateTime?

  signatures Signature[]
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([buyerId])
  @@index([sellerId])
  @@index([status])
  @@index([listingId])
  @@index([createdAt]) // NEW
}

model Signature {
  id                 String @id @default(cuid())

  transaction        Transaction  @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  transactionId      String

  party              Party        // SELLER or BUYER
  docusignEnvelopeId String?
  status             SignatureStatus @default(PENDING)
  completedAt        DateTime?

  @@index([transactionId, party])
}

/* ---------------- Onboarding Profile ---------------- */

model UserProfile {
  id               String       @id @default(cuid())

  // one-to-one with User
  user             User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId           String       @unique

  // NEW onboarding-friendly fields
  firstName        String?
  lastName         String?
  fullName         String        // keep required; we compose from first+last in API
  address          String?
  email            String?
  phone            String?
  cellPhone        String?
  smsOptIn         Boolean       @default(false)
  districts        String[]      @default([])   // multi-districts selected

  // Legacy/optional fields retained for back-compat
  company          String?
  tradeRole        ProfileRole   // Buyer, Seller, Both, District Admin
  primaryDistrict  String?
  waterTypes       String[]      @default([])   // e.g. ["CVP Allocation","Pumping Credits"]

  acceptTerms      Boolean

  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  @@index([userId])
}

// -------- NEW: Farm records tied to a user --------

model Farm {
  id            String   @id @default(cuid())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String
  name          String?
  accountNumber String?
  district      String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([userId])
}

// -------- NEW: Notifications (optional but recommended) --------

model Notification {
  id                   String   @id @default(cuid())
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId               String

  kind                 NotificationKind
  subject              String
  body                 String?
  meta                 Json?        // arbitrary payload; e.g., { listingId, transactionId, pricePerAF }
  deliveredAt          DateTime?    // when email actually went out

  // Handy cross-links (not FK to keep flexible)
  relatedListingId     String?
  relatedTransactionId String?

  createdAt            DateTime @default(now())

  @@index([userId, deliveredAt])
  @@index([relatedListingId])
  @@index([relatedTransactionId])
  @@index([kind, createdAt])
}

// --------------- Enums ----------------

enum Role {
  USER
  ADMIN
}

enum Party {
  SELLER
  BUYER
}

enum ListingStatus {
  ACTIVE
  UNDER_CONTRACT
  SOLD
  ARCHIVED
}

enum TransactionType {
  BUY_NOW
  OFFER
  AUCTION
}

enum TransactionStatus {
  INITIATED
  PENDING_SELLER_SIGNATURE
  AWAITING_BUYER_PAYMENT
  PAYMENT_IN_REVIEW
  PENDING_BUYER_SIGNATURE
  COMPLIANCE_REVIEW
  APPROVED
  FUNDS_RELEASED
  CANCELLED
}

enum SignatureStatus {
  PENDING
  SENT
  COMPLETED
  DECLINED
}

enum PaymentMethod {
  STRIPE
  ESCROW_COM
}

enum ProfileRole {
  BUYER
  SELLER
  BOTH
  DISTRICT_ADMIN
}

enum ListingKind {
  SELL
  BUY
}

// NEW: kinds of notifications we send
enum NotificationKind {
  BID_RECEIVED
  BUY_NOW_STARTED
  DOCS_SENT
  OFFER_RECEIVED
  OFFER_ACCEPTED
  OFFER_DECLINED
  COUNTER_OFFER
  PAYMENT_REQUESTED
  PAYMENT_CONFIRMED
}
