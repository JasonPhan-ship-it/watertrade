// frontend/prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/* ========================= Users & Profiles ========================= */

model User {
  id        String  @id @default(cuid())
  email     String  @unique
  name      String?
  role      Role    @default(USER)

  // External auth id (Clerk, etc.)
  clerkId   String? @unique

  // Subscription fields for premium membership
  subscriptionStatus     String?   @default("free")
  subscriptionUpdatedAt  DateTime?
  stripeCustomerId       String?   @unique
  stripeSubscriptionId   String?   @unique

  // Relations
  listings            Listing[]                           // listings this user is selling
  buyerTransactions   Transaction[] @relation("BuyerTransactions")
  sellerTransactions  Transaction[] @relation("SellerTransactions")
  bids                Bid[]                                 // back-relation for Bid.bidder
  notifications       Notification[]                        // in-app notifications (optional)
  profile             UserProfile?                          // one-to-one profile created via onboarding
  farms               Farm[]                                // farms owned by the user

  // Negotiations (new)
  tradesAsBuyer       Trade[] @relation("TradeBuyer")
  tradesAsSeller      Trade[] @relation("TradeSeller")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([role])
  @@index([subscriptionStatus])
  @@index([clerkId])
}

/* ========================= Listings & Bids ========================= */

model Listing {
  id           String         @id @default(cuid())

  // Handy for UI & search
  title        String         @default("Untitled Listing")
  description  String?

  // Core water trade fields
  district     String
  waterType    String

  // Human-readable window (kept for display/back-compat)
  availability String

  // Real dates for sorting/filters
  availabilityStart DateTime  @default(now())
  availabilityEnd   DateTime  @default(now())

  acreFeet     Int
  pricePerAF   Int                 // cents

  // SELL or BUY (maps to form "type")
  kind         ListingKind     @default(SELL)

  status       ListingStatus   @default(ACTIVE)

  // Seller (optional for seed)
  seller       User?           @relation(fields: [sellerId], references: [id], onDelete: SetNull)
  sellerId     String?

  // Auction options
  isAuction      Boolean       @default(false)
  auctionEndsAt  DateTime?
  reservePrice   Int?          // cents per AF

  bids          Bid[]
  transactions  Transaction[]  // escrow/payments pipeline
  trades        Trade[]        // negotiations pipeline (new)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([status, isAuction, auctionEndsAt])
  @@index([district, waterType])
  @@index([createdAt])
  @@index([sellerId])
}

model Bid {
  id         String   @id @default(cuid())

  listing    Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  listingId  String

  bidder     User     @relation(fields: [bidderId], references: [id], onDelete: Cascade)
  bidderId   String

  pricePerAF Int      // cents per AF
  createdAt  DateTime @default(now())

  @@index([listingId, createdAt])
  @@index([bidderId, createdAt])
}

/* ========================= Negotiations (NEW) =========================
   This runs the offer ↔ counter loop, acceptance, and signature requests.
   When both parties sign, you can create/attach a Transaction record. */

model Trade {
  id                 String        @id @default(cuid())

  listing            Listing       @relation(fields: [listingId], references: [id], onDelete: Restrict)
  listingId          String

  seller             User          @relation("TradeSeller", fields: [sellerUserId], references: [id], onDelete: Restrict)
  sellerUserId       String

  buyer              User          @relation("TradeBuyer", fields: [buyerUserId], references: [id], onDelete: Restrict)
  buyerUserId        String

  // Snapshot fields (denormalized for emails/audits & immutability per round)
  district           String
  waterType          String?
  volumeAf           Int
  pricePerAf         Int           // cents (per AF)
  windowLabel        String?

  status             TradeStatus   @default(OFFERED)
  round              Int           @default(1)
  lastActor          Party?

  // Magic-link tokens for email access (store hashed if desired)
  sellerToken        String        @default(uuid())
  buyerToken         String        @default(uuid())

  // Signature progression (simple flags; full details in Signature/Transaction if you prefer)
  buyerSignStatus    SignatureProgress @default(NONE)
  sellerSignStatus   SignatureProgress @default(NONE)
  buyerSignUrl       String?
  sellerSignUrl      String?

  // Final doc once fully executed (or stored on Transaction)
  agreementUrl       String?

  // Optional link into escrow/payments pipeline
  transaction   Transaction? @relation("TradeToTransaction", fields: [transactionId], references: [id], onDelete: SetNull)
  transactionId String?

  // Optimistic concurrency
  version            Int           @default(0)

  events             TradeEvent[]

  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt

  @@index([listingId, status, createdAt])
  @@index([sellerUserId, status])
  @@index([buyerUserId, status])
}

model TradeEvent {
  id         String   @id @default(cuid())
  trade      Trade    @relation(fields: [tradeId], references: [id], onDelete: Cascade)
  tradeId    String

  actor      String   // "buyer" | "seller" | "system"
  kind       String   // "OFFER" | "COUNTER" | "ACCEPT" | "DECLINE" | "SIGN_REQUEST" | "SIGNED" | ...
  payload    Json
  createdAt  DateTime @default(now())

  @@index([tradeId, createdAt])
}

/* ========================= Escrow / Payments =========================
   Keep your existing Transaction/Signature for the payment/compliance side.
   (Trade ↔ Transaction link is named "TradeToTransaction".) */

model Transaction {
  id          String            @id @default(cuid())
  type        TransactionType
  status      TransactionStatus @default(INITIATED)

  listing     Listing   @relation(fields: [listingId], references: [id], onDelete: Restrict)
  listingId   String

  seller      User      @relation("SellerTransactions", fields: [sellerId], references: [id], onDelete: Restrict)
  sellerId    String

  buyer       User      @relation("BuyerTransactions", fields: [buyerId], references: [id], onDelete: Restrict)
  buyerId     String

  acreFeet    Int
  pricePerAF  Int        // cents
  totalAmount Int        // cents (acreFeet * pricePerAF)

  // Snapshots for audits/emails
  listingTitleSnapshot String?
  sellerNameSnapshot   String?
  sellerEmailSnapshot  String?
  buyerNameSnapshot    String?
  buyerEmailSnapshot   String?

  // Offer niceties (optional)
  offerExpiresAt       DateTime?

  paymentMethod PaymentMethod?
  paymentId      String?     // Stripe PI id or Escrow.com id

  complianceApprovedBy String?
  complianceApprovedAt DateTime?

  // Final docs (duplicated here if you prefer Transaction-centric doc storage)
  agreementUrl String?

  // Back-relation to Trade (no extra FK here)
  trade Trade? @relation("TradeToTransaction")

  signatures Signature[]
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([buyerId])
  @@index([sellerId])
  @@index([status])
  @@index([listingId])
  @@index([createdAt])
}

model Signature {
  id                 String @id @default(cuid())

  transaction        Transaction  @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  transactionId      String

  party              Party
  docusignEnvelopeId String?
  status             SignatureStatus @default(PENDING)
  completedAt        DateTime?
  signerUrl          String?         // optional convenience
  documentUrl        String?         // optional convenience

  @@index([transactionId, party])
}

/* ========================= Onboarding Profile ========================= */

model UserProfile {
  id               String       @id @default(cuid())

  // one-to-one with User
  user             User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId           String       @unique

  // Onboarding-friendly fields
  firstName        String?
  lastName         String?
  fullName         String       // required single source of truth
  address          String?
  email            String?
  // phone          String?      // intentionally removed from UI; keep or drop DB column per your migration plan
  cellPhone        String?
  smsOptIn         Boolean      @default(false)
  districts        String[]     @default([])

  // Legacy/optional fields retained for back-compat
  company          String?
  tradeRole        ProfileRole  @default(BOTH)
  primaryDistrict  String?
  waterTypes       String[]     @default([])

  acceptTerms      Boolean      @default(false)

  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  @@index([userId])
}

/* ========================= Farm & Notifications ========================= */

model Farm {
  id            String   @id @default(cuid())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String
  name          String?
  accountNumber String?
  district      String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([userId])
}

model Notification {
  id                   String   @id @default(cuid())
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId               String

  kind                 NotificationKind
  subject              String
  body                 String?
  meta                 Json?
  deliveredAt          DateTime?

  relatedListingId     String?
  relatedTransactionId String?
  relatedTradeId       String?    // NEW (optional cross-link)

  createdAt            DateTime @default(now())

  @@index([userId, deliveredAt])
  @@index([relatedListingId])
  @@index([relatedTransactionId])
  @@index([relatedTradeId])
  @@index([kind, createdAt])
}

/* ========================= Enums ========================= */

enum Role {
  USER
  ADMIN
}

enum Party {
  SELLER
  BUYER
}

enum ListingStatus {
  ACTIVE
  UNDER_CONTRACT
  SOLD
  ARCHIVED
}

enum TransactionType {
  BUY_NOW
  OFFER
  AUCTION
}

enum TransactionStatus {
  INITIATED
  PENDING_SELLER_SIGNATURE
  AWAITING_BUYER_PAYMENT
  PAYMENT_IN_REVIEW
  PENDING_BUYER_SIGNATURE
  COMPLIANCE_REVIEW
  APPROVED
  FUNDS_RELEASED
  CANCELLED
}

enum SignatureStatus {
  PENDING
  SENT
  COMPLETED
  DECLINED
}

enum PaymentMethod {
  STRIPE
  ESCROW_COM
}

enum ProfileRole {
  BUYER
  SELLER
  BOTH
  DISTRICT_ADMIN
}

enum ListingKind {
  SELL
  BUY
}

enum NotificationKind {
  BID_RECEIVED
  BUY_NOW_STARTED
  DOCS_SENT
  OFFER_RECEIVED
  OFFER_ACCEPTED
  OFFER_DECLINED
  COUNTER_OFFER
  PAYMENT_REQUESTED
  PAYMENT_CONFIRMED
}

/* ---- NEW (Negotiations) ---- */

enum TradeStatus {
  OFFERED
  COUNTERED_BY_SELLER
  COUNTERED_BY_BUYER
  ACCEPTED_PENDING_BUYER_SIGNATURE
  ACCEPTED_PENDING_SELLER_SIGNATURE
  FULLY_EXECUTED
  DECLINED
  CANCELLED
  EXPIRED
}

enum SignatureProgress {
  NONE
  REQUESTED
  SIGNED
}
