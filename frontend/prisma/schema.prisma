// Revised schema.prisma with fixes

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String  @id @default(cuid())
  email     String  @unique
  name      String?
  role      Role    @default(USER)
  clerkId   String? @unique

  // Subscription fields - make optional for graceful degradation
  subscriptionStatus     String?   @default("free")
  subscriptionUpdatedAt  DateTime?
  stripeCustomerId       String?   @unique
  stripeSubscriptionId   String?   @unique

  // Relations
  listings            Listing[]                  
  buyerTransactions   Transaction[] @relation("BuyerTransactions")
  sellerTransactions  Transaction[] @relation("SellerTransactions")
  bids                Bid[]                      
  notifications       Notification[]             
  profile             UserProfile?               
  farms               Farm[]                     

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([role])
  @@index([subscriptionStatus])
  @@index([clerkId]) // Add this for performance
}

model Listing {
  id           String         @id @default(cuid())
  title        String         @default("Untitled Listing")
  description  String?

  // Core water trade fields
  district     String
  waterType    String
  availability String         // Keep for backward compatibility

  // Real dates - make required with sensible defaults
  availabilityStart DateTime  @default(now())
  availabilityEnd   DateTime  @default(dbgenerated("now() + interval '60 days'"))

  acreFeet     Int
  pricePerAF   Int             // cents - add constraint
  kind         ListingKind     @default(SELL)
  status       ListingStatus   @default(ACTIVE)

  // Seller relation - make optional for flexibility
  seller       User?           @relation(fields: [sellerId], references: [id], onDelete: SetNull)
  sellerId     String?

  // Auction options
  isAuction      Boolean       @default(false)
  auctionEndsAt  DateTime?     // Should be required if isAuction = true
  reservePrice   Int?          // cents per AF

  // Relations
  bids          Bid[]
  transactions  Transaction[]  

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([status, isAuction, auctionEndsAt])
  @@index([district, waterType])
  @@index([createdAt])
  @@index([sellerId]) // Add for performance
  
  // Add constraint to ensure auction listings have end dates
  @@check(constraint: "auction_end_date_check", value: "(isAuction = false) OR (auctionEndsAt IS NOT NULL)")
  // Ensure positive pricing
  @@check(constraint: "positive_price_check", value: "pricePerAF > 0")
}

// Rest of models remain the same but with these additions:

model Transaction {
  id          String            @id @default(cuid())
  type        TransactionType
  status      TransactionStatus @default(INITIATED)

  listing     Listing   @relation(fields: [listingId], references: [id], onDelete: Restrict)
  listingId   String

  seller      User      @relation("SellerTransactions", fields: [sellerId], references: [id], onDelete: Restrict)
  sellerId    String

  buyer       User      @relation("BuyerTransactions", fields: [buyerId], references: [id], onDelete: Restrict)
  buyerId     String

  acreFeet    Int
  pricePerAF  Int        // cents
  totalAmount Int        // cents (acreFeet * pricePerAF)

  // Snapshots for audits/emails
  listingTitleSnapshot String?
  sellerNameSnapshot   String?
  sellerEmailSnapshot  String?
  buyerNameSnapshot    String?
  buyerEmailSnapshot   String?

  offerExpiresAt       DateTime?
  paymentMethod        PaymentMethod?
  paymentId            String?     

  complianceApprovedBy String?
  complianceApprovedAt DateTime?

  signatures Signature[]
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([buyerId])
  @@index([sellerId])
  @@index([status])
  @@index([listingId])
  @@index([createdAt])
  
  // Add constraint to ensure positive amounts
  @@check(constraint: "positive_amounts", value: "acreFeet > 0 AND pricePerAF > 0 AND totalAmount > 0")
}

model UserProfile {
  id               String       @id @default(cuid())
  user             User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId           String       @unique

  // Make these required for better data quality
  firstName        String?
  lastName         String?
  fullName         String       // Keep as required
  
  // Contact info
  address          String?
  email            String?      // Should validate email format
  phone            String?
  cellPhone        String?
  smsOptIn         Boolean      @default(false)
  
  // Water trading preferences
  districts        String[]     @default([])
  company          String?
  tradeRole        ProfileRole  @default(BOTH)   
  primaryDistrict  String?
  waterTypes       String[]     @default([])
  acceptTerms      Boolean      @default(false)  

  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  @@index([userId])
}

// Add the missing enums and models...
enum Role {
  USER
  ADMIN
}

enum ListingKind {
  SELL
  BUY
}

enum ListingStatus {
  ACTIVE
  UNDER_CONTRACT
  SOLD
  ARCHIVED
}

enum TransactionType {
  BUY_NOW
  OFFER
  AUCTION
}

enum TransactionStatus {
  INITIATED
  PENDING_SELLER_SIGNATURE
  AWAITING_BUYER_PAYMENT
  PAYMENT_IN_REVIEW
  PENDING_BUYER_SIGNATURE
  COMPLIANCE_REVIEW
  APPROVED
  FUNDS_RELEASED
  CANCELLED
}

enum ProfileRole {
  BUYER
  SELLER
  BOTH
  DISTRICT_ADMIN
}

enum PaymentMethod {
  STRIPE
  ESCROW_COM
}

enum Party {
  SELLER
  BUYER
}

enum SignatureStatus {
  PENDING
  SENT
  COMPLETED
  DECLINED
}

enum NotificationKind {
  BID_RECEIVED
  BUY_NOW_STARTED
  DOCS_SENT
  OFFER_RECEIVED
  OFFER_ACCEPTED
  OFFER_DECLINED
  COUNTER_OFFER
  PAYMENT_REQUESTED
  PAYMENT_CONFIRMED
}

// Include remaining models (Bid, Signature, Farm, Notification) with indexes...
